<!DOCTYPE html>
<html>
    <head>
        <style>
            .tree_node + ul{
                display: none;
            }
            .tree_node.show + ul{
                display: block;
            }            
        </style>
    </head>
    <body>
        <tree-componenet></tree-componenet>
        <script>
            class tree extends HTMLElement{
                constructor(){
                    super();
                }

                connectedCallback(){
                    this.nodeIdArray = [];
                    this.nodeList = {};
                    this.render();
                    this.setEvent();
                }

                async getDataFromServer(){
                    // let response = await fetch('http://192.168.0.51:5000/dataFromServer');
                    // let response = await fetch('http://192.168.56.1:5000/dataFromServer');
                    let response = await fetch(`http://192.168.56.1:5000/dataFromDb?query=WITH recursive cte (id, pid, NAME, description) as(
                                                    SELECT id, pid, NAME, description
                                                    FROM tree_table
                                                    WHERE pid=0
                                                    UNION all
                                                    SELECT a.id, a.pid, a.name, a.description
                                                    FROM tree_table a
                                                    INNER JOIN cte
                                                    ON a.pid = cte.id
                                                )
                                                SELECT * FROM cte ORDER BY pid asc, id asc;`);
                    let responseJson = await response.json();
                    this.initialData = responseJson;
                }

                async render(){
                    await this.getDataFromServer();
                    this.constructTreeWithInitialData();
                }

                constructTreeWithInitialData(){
                    let copiedData = this.initialData;
                    while(copiedData.length!=0){
                        let tempObject = copiedData.shift();
                        // console.log(tempObject.id)
                        this.addItem(tempObject.pid, tempObject);
                    }
                }

                checkChildNodes(element, querySelector){
                    let childNodeList = element.childNodes;
                    for(var i=0; i<element.childNodes.length; i++){
                        if(childNodeList[i].matches(querySelector)){
                            return true; // 해당 element를 포함하고 있음
                        }
                    }
                    return false; // 해당 element를 포함하고 있지 않음
                }

                setEvent(){
                    this.customClickEventListener();
                }

                customClickEventListener(){
                    this.addEventListener('click', function(e){
                        this.getSelectedId(e);
                        this.getSelectedItem(e);
                    });
                }

                getSelectedId(event){
                    if(event.target.matches('span')){
                        console.log('check elementId in getSelectedId() : ' + event.target.dataset.id);
                    }
                }
                getSelectedItem(event){
                    if(event.target.matches('span')){
                        console.log('check elementId in getSelectedItem() ... ');
                        console.log(event.target.nodeData);
                    }
                }

                addItem(pid, elementData){
                    let tempElement = document.createElement('span');
                    tempElement.innerText = elementData['NAME'];
                    tempElement.setAttribute('data-id', elementData['id']);
                    tempElement.nodeData = elementData;
                    
                    if(!this.nodeIdArray.includes(elementData['pid'])){
                        this.appendChild(tempElement);
                    }else{ // pid가 존재하는 경우에 ...
                        if(!this.checkChildNodes(this.nodeList[pid].parentElement, 'ul')){       //ul 태그가 존재하지않는다면 ...
                            let tempUl = document.createElement('ul');
                            let tempLi = document.createElement('li');
                            tempLi.appendChild(tempElement);
                            tempUl.appendChild(tempLi);
                            this.nodeList[pid].after(tempUl);       
                        }else{                                                              //ul 태그가 있다면 ...                                                 
                            let tempLi = document.createElement('li');
                            tempLi.appendChild(tempElement);
                            this.nodeList[pid].nextElementSibling.appendChild(tempLi);
                        }
                    }
                    this.nodeIdArray.push(elementData.id);
                    this.nodeList[elementData.id] = tempElement; // id, element 쌍으로 객체에 저장
                }
            }
            customElements.define('tree-componenet', tree);
        </script>
    </body>
</html>